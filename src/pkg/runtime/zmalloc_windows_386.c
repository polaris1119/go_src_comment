// auto generated by go tool dist
// goos=windows goarch=386

#include "runtime.h"
#include "arch_GOARCH.h"
#include "malloc.h"
#include "type.h"
#include "typekind.h"
#include "race.h"

#line 17 "d:\Go1.1\src\pkg\runtime\malloc.goc"
MHeap *runtime·mheap; 
#line 19 "d:\Go1.1\src\pkg\runtime\malloc.goc"
int32 runtime·checking; 
#line 21 "d:\Go1.1\src\pkg\runtime\malloc.goc"
extern MStats mstats; 
#line 23 "d:\Go1.1\src\pkg\runtime\malloc.goc"
extern volatile intgo runtime·MemProfileRate; 
#line 28 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void* 
runtime·mallocgc ( uintptr size , uint32 flag , int32 dogc , int32 zeroed ) 
{ 
int32 sizeclass; 
intgo rate; 
MCache *c; 
uintptr npages; 
MSpan *s; 
void *v; 
#line 38 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( runtime·gcwaiting && g != m->g0 && m->locks == 0 && dogc ) 
runtime·gosched ( ) ; 
if ( m->mallocing ) 
runtime·throw ( "malloc/free - deadlock" ) ; 
m->mallocing = 1; 
if ( size == 0 ) 
size = 1; 
#line 46 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( DebugTypeAtBlockEnd ) 
size += sizeof ( uintptr ) ; 
#line 49 "d:\Go1.1\src\pkg\runtime\malloc.goc"
c = m->mcache; 
c->local_nmalloc++; 
if ( size <= MaxSmallSize ) { 
#line 53 "d:\Go1.1\src\pkg\runtime\malloc.goc"
sizeclass = runtime·SizeToClass ( size ) ; 
size = runtime·class_to_size[sizeclass]; 
v = runtime·MCache_Alloc ( c , sizeclass , size , zeroed ) ; 
if ( v == nil ) 
runtime·throw ( "out of memory" ) ; 
c->local_alloc += size; 
c->local_total_alloc += size; 
c->local_by_size[sizeclass].nmalloc++; 
} else { 
#line 65 "d:\Go1.1\src\pkg\runtime\malloc.goc"
npages = size >> PageShift; 
if ( ( size & PageMask ) != 0 ) 
npages++; 
s = runtime·MHeap_Alloc ( runtime·mheap , npages , 0 , 1 , zeroed ) ; 
if ( s == nil ) 
runtime·throw ( "out of memory" ) ; 
size = npages<<PageShift; 
c->local_alloc += size; 
c->local_total_alloc += size; 
v = ( void* ) ( s->start << PageShift ) ; 
#line 77 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·markspan ( v , 0 , 0 , true ) ; 
} 
#line 80 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( sizeof ( void* ) == 4 && c->local_total_alloc >= ( 1<<30 ) ) { 
#line 82 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·lock ( runtime·mheap ) ; 
runtime·purgecachedstats ( c ) ; 
runtime·unlock ( runtime·mheap ) ; 
} 
#line 87 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( ! ( flag & FlagNoGC ) ) 
runtime·markallocated ( v , size , ( flag&FlagNoPointers ) != 0 ) ; 
#line 90 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( DebugTypeAtBlockEnd ) 
* ( uintptr* ) ( ( uintptr ) v+size-sizeof ( uintptr ) ) = 0; 
#line 93 "d:\Go1.1\src\pkg\runtime\malloc.goc"
m->mallocing = 0; 
#line 95 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( ! ( flag & FlagNoProfiling ) && ( rate = runtime·MemProfileRate ) > 0 ) { 
if ( size >= rate ) 
goto profile; 
if ( m->mcache->next_sample > size ) 
m->mcache->next_sample -= size; 
else { 
#line 103 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( rate > 0x3fffffff ) 
rate = 0x3fffffff; 
m->mcache->next_sample = runtime·fastrand1 ( ) % ( 2*rate ) ; 
profile: 
runtime·setblockspecial ( v , true ) ; 
runtime·MProf_Malloc ( v , size ) ; 
} 
} 
#line 112 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( dogc && mstats.heap_alloc >= mstats.next_gc ) 
runtime·gc ( 0 ) ; 
#line 115 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( raceenabled ) { 
runtime·racemalloc ( v , size , m->racepc ) ; 
m->racepc = nil; 
} 
return v; 
} 
#line 122 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void* 
runtime·malloc ( uintptr size ) 
{ 
return runtime·mallocgc ( size , 0 , 0 , 1 ) ; 
} 
#line 129 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void 
runtime·free ( void *v ) 
{ 
int32 sizeclass; 
MSpan *s; 
MCache *c; 
uint32 prof; 
uintptr size; 
#line 138 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( v == nil ) 
return; 
#line 144 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( m->mallocing ) 
runtime·throw ( "malloc/free - deadlock" ) ; 
m->mallocing = 1; 
#line 148 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( !runtime·mlookup ( v , nil , nil , &s ) ) { 
runtime·printf ( "free %p: not an allocated block\n" , v ) ; 
runtime·throw ( "free runtime·mlookup" ) ; 
} 
prof = runtime·blockspecial ( v ) ; 
#line 154 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( raceenabled ) 
runtime·racefree ( v ) ; 
#line 158 "d:\Go1.1\src\pkg\runtime\malloc.goc"
sizeclass = s->sizeclass; 
c = m->mcache; 
if ( sizeclass == 0 ) { 
#line 162 "d:\Go1.1\src\pkg\runtime\malloc.goc"
size = s->npages<<PageShift; 
* ( uintptr* ) ( s->start<<PageShift ) = ( uintptr ) 0xfeedfeedfeedfeedll; 
#line 166 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·markfreed ( v , size ) ; 
runtime·unmarkspan ( v , 1<<PageShift ) ; 
runtime·MHeap_Free ( runtime·mheap , s , 1 ) ; 
} else { 
#line 171 "d:\Go1.1\src\pkg\runtime\malloc.goc"
size = runtime·class_to_size[sizeclass]; 
if ( size > sizeof ( uintptr ) ) 
( ( uintptr* ) v ) [1] = ( uintptr ) 0xfeedfeedfeedfeedll; 
#line 177 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·markfreed ( v , size ) ; 
c->local_by_size[sizeclass].nfree++; 
runtime·MCache_Free ( c , v , sizeclass , size ) ; 
} 
c->local_nfree++; 
c->local_alloc -= size; 
if ( prof ) 
runtime·MProf_Free ( v , size ) ; 
m->mallocing = 0; 
} 
#line 188 "d:\Go1.1\src\pkg\runtime\malloc.goc"
int32 
runtime·mlookup ( void *v , byte **base , uintptr *size , MSpan **sp ) 
{ 
uintptr n , i; 
byte *p; 
MSpan *s; 
#line 195 "d:\Go1.1\src\pkg\runtime\malloc.goc"
m->mcache->local_nlookup++; 
if ( sizeof ( void* ) == 4 && m->mcache->local_nlookup >= ( 1<<30 ) ) { 
#line 198 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·lock ( runtime·mheap ) ; 
runtime·purgecachedstats ( m->mcache ) ; 
runtime·unlock ( runtime·mheap ) ; 
} 
#line 203 "d:\Go1.1\src\pkg\runtime\malloc.goc"
s = runtime·MHeap_LookupMaybe ( runtime·mheap , v ) ; 
if ( sp ) 
*sp = s; 
if ( s == nil ) { 
runtime·checkfreed ( v , 1 ) ; 
if ( base ) 
*base = nil; 
if ( size ) 
*size = 0; 
return 0; 
} 
#line 215 "d:\Go1.1\src\pkg\runtime\malloc.goc"
p = ( byte* ) ( ( uintptr ) s->start<<PageShift ) ; 
if ( s->sizeclass == 0 ) { 
#line 218 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( base ) 
*base = p; 
if ( size ) 
*size = s->npages<<PageShift; 
return 1; 
} 
#line 225 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( ( byte* ) v >= ( byte* ) s->limit ) { 
#line 227 "d:\Go1.1\src\pkg\runtime\malloc.goc"
return 0; 
} 
#line 230 "d:\Go1.1\src\pkg\runtime\malloc.goc"
n = s->elemsize; 
if ( base ) { 
i = ( ( byte* ) v - p ) /n; 
*base = p + i*n; 
} 
if ( size ) 
*size = n; 
#line 238 "d:\Go1.1\src\pkg\runtime\malloc.goc"
return 1; 
} 
#line 241 "d:\Go1.1\src\pkg\runtime\malloc.goc"
MCache* 
runtime·allocmcache ( void ) 
{ 
intgo rate; 
MCache *c; 
#line 247 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·lock ( runtime·mheap ) ; 
c = runtime·FixAlloc_Alloc ( &runtime·mheap->cachealloc ) ; 
mstats.mcache_inuse = runtime·mheap->cachealloc.inuse; 
mstats.mcache_sys = runtime·mheap->cachealloc.sys; 
runtime·unlock ( runtime·mheap ) ; 
runtime·memclr ( ( byte* ) c , sizeof ( *c ) ) ; 
#line 255 "d:\Go1.1\src\pkg\runtime\malloc.goc"
rate = runtime·MemProfileRate; 
if ( rate > 0x3fffffff ) 
rate = 0x3fffffff; 
if ( rate != 0 ) 
c->next_sample = runtime·fastrand1 ( ) % ( 2*rate ) ; 
#line 261 "d:\Go1.1\src\pkg\runtime\malloc.goc"
return c; 
} 
#line 264 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void 
runtime·freemcache ( MCache *c ) 
{ 
runtime·MCache_ReleaseAll ( c ) ; 
runtime·lock ( runtime·mheap ) ; 
runtime·purgecachedstats ( c ) ; 
runtime·FixAlloc_Free ( &runtime·mheap->cachealloc , c ) ; 
runtime·unlock ( runtime·mheap ) ; 
} 
#line 274 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void 
runtime·purgecachedstats ( MCache *c ) 
{ 
#line 278 "d:\Go1.1\src\pkg\runtime\malloc.goc"
mstats.heap_alloc += c->local_cachealloc; 
c->local_cachealloc = 0; 
mstats.heap_objects += c->local_objects; 
c->local_objects = 0; 
mstats.nmalloc += c->local_nmalloc; 
c->local_nmalloc = 0; 
mstats.nfree += c->local_nfree; 
c->local_nfree = 0; 
mstats.nlookup += c->local_nlookup; 
c->local_nlookup = 0; 
mstats.alloc += c->local_alloc; 
c->local_alloc= 0; 
mstats.total_alloc += c->local_total_alloc; 
c->local_total_alloc= 0; 
} 
#line 294 "d:\Go1.1\src\pkg\runtime\malloc.goc"
uintptr runtime·sizeof_C_MStats = sizeof ( MStats ) ; 
#line 296 "d:\Go1.1\src\pkg\runtime\malloc.goc"
#define MaxArena32 ( 2U<<30 ) 
#line 298 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void 
runtime·mallocinit ( void ) 
{ 
byte *p; 
uintptr arena_size , bitmap_size; 
extern byte end[]; 
byte *want; 
uintptr limit; 
#line 307 "d:\Go1.1\src\pkg\runtime\malloc.goc"
p = nil; 
arena_size = 0; 
bitmap_size = 0; 
#line 312 "d:\Go1.1\src\pkg\runtime\malloc.goc"
USED ( p ) ; 
USED ( arena_size ) ; 
USED ( bitmap_size ) ; 
#line 316 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( ( runtime·mheap = runtime·SysAlloc ( sizeof ( *runtime·mheap ) ) ) == nil ) 
runtime·throw ( "runtime: cannot allocate heap metadata" ) ; 
#line 319 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·InitSizes ( ) ; 
#line 324 "d:\Go1.1\src\pkg\runtime\malloc.goc"
limit = 0; 
#line 329 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( sizeof ( void* ) == 8 && ( limit == 0 || limit > ( 1<<30 ) ) ) { 
#line 352 "d:\Go1.1\src\pkg\runtime\malloc.goc"
arena_size = MaxMem; 
bitmap_size = arena_size / ( sizeof ( void* ) *8/4 ) ; 
p = runtime·SysReserve ( ( void* ) ( 0x00c0ULL<<32 ) , bitmap_size + arena_size ) ; 
} 
if ( p == nil ) { 
#line 374 "d:\Go1.1\src\pkg\runtime\malloc.goc"
bitmap_size = MaxArena32 / ( sizeof ( void* ) *8/4 ) ; 
arena_size = 512<<20; 
if ( limit > 0 && arena_size+bitmap_size > limit ) { 
bitmap_size = ( limit / 9 ) & ~ ( ( 1<<PageShift ) - 1 ) ; 
arena_size = bitmap_size * 8; 
} 
#line 390 "d:\Go1.1\src\pkg\runtime\malloc.goc"
want = ( byte* ) ( ( ( uintptr ) end + ( 1<<18 ) + ( 1<<20 ) - 1 ) &~ ( ( 1<<20 ) -1 ) ) ; 
p = runtime·SysReserve ( want , bitmap_size + arena_size ) ; 
if ( p == nil ) 
runtime·throw ( "runtime: cannot reserve arena virtual address space" ) ; 
if ( ( uintptr ) p & ( ( ( uintptr ) 1<<PageShift ) -1 ) ) 
runtime·printf ( "runtime: SysReserve returned unaligned address %p; asked for %p" , p , bitmap_size+arena_size ) ; 
} 
if ( ( uintptr ) p & ( ( ( uintptr ) 1<<PageShift ) -1 ) ) 
runtime·throw ( "runtime: SysReserve returned unaligned address" ) ; 
#line 400 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·mheap->bitmap = p; 
runtime·mheap->arena_start = p + bitmap_size; 
runtime·mheap->arena_used = runtime·mheap->arena_start; 
runtime·mheap->arena_end = runtime·mheap->arena_start + arena_size; 
#line 406 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·MHeap_Init ( runtime·mheap , runtime·SysAlloc ) ; 
m->mcache = runtime·allocmcache ( ) ; 
#line 410 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·free ( runtime·malloc ( 1 ) ) ; 
} 
#line 413 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void* 
runtime·MHeap_SysAlloc ( MHeap *h , uintptr n ) 
{ 
byte *p; 
#line 418 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( n > h->arena_end - h->arena_used ) { 
#line 421 "d:\Go1.1\src\pkg\runtime\malloc.goc"
byte *new_end; 
uintptr needed; 
#line 424 "d:\Go1.1\src\pkg\runtime\malloc.goc"
needed = ( uintptr ) h->arena_used + n - ( uintptr ) h->arena_end; 
#line 426 "d:\Go1.1\src\pkg\runtime\malloc.goc"
needed = ( needed + ( 256<<20 ) - 1 ) & ~ ( ( 256<<20 ) -1 ) ; 
new_end = h->arena_end + needed; 
if ( new_end <= h->arena_start + MaxArena32 ) { 
p = runtime·SysReserve ( h->arena_end , new_end - h->arena_end ) ; 
if ( p == h->arena_end ) 
h->arena_end = new_end; 
} 
} 
if ( n <= h->arena_end - h->arena_used ) { 
#line 436 "d:\Go1.1\src\pkg\runtime\malloc.goc"
p = h->arena_used; 
runtime·SysMap ( p , n ) ; 
h->arena_used += n; 
runtime·MHeap_MapBits ( h ) ; 
if ( raceenabled ) 
runtime·racemapshadow ( p , n ) ; 
return p; 
} 
#line 446 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( sizeof ( void* ) == 8 && ( uintptr ) h->bitmap >= 0xffffffffU ) 
return nil; 
#line 452 "d:\Go1.1\src\pkg\runtime\malloc.goc"
p = runtime·SysAlloc ( n ) ; 
if ( p == nil ) 
return nil; 
#line 456 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( p < h->arena_start || p+n - h->arena_start >= MaxArena32 ) { 
runtime·printf ( "runtime: memory allocated by OS (%p) not in usable range [%p,%p)\n" , 
p , h->arena_start , h->arena_start+MaxArena32 ) ; 
runtime·SysFree ( p , n ) ; 
return nil; 
} 
#line 463 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( p+n > h->arena_used ) { 
h->arena_used = p+n; 
if ( h->arena_used > h->arena_end ) 
h->arena_end = h->arena_used; 
runtime·MHeap_MapBits ( h ) ; 
if ( raceenabled ) 
runtime·racemapshadow ( p , n ) ; 
} 
#line 472 "d:\Go1.1\src\pkg\runtime\malloc.goc"
return p; 
} 
#line 475 "d:\Go1.1\src\pkg\runtime\malloc.goc"
static Lock settype_lock; 
#line 477 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void 
runtime·settype_flush ( M *mp , bool sysalloc ) 
{ 
uintptr *buf , *endbuf; 
uintptr size , ofs , j , t; 
uintptr ntypes , nbytes2 , nbytes3; 
uintptr *data2; 
byte *data3; 
bool sysalloc3; 
void *v; 
uintptr typ , p; 
MSpan *s; 
#line 490 "d:\Go1.1\src\pkg\runtime\malloc.goc"
buf = mp->settype_buf; 
endbuf = buf + mp->settype_bufsize; 
#line 493 "d:\Go1.1\src\pkg\runtime\malloc.goc"
runtime·lock ( &settype_lock ) ; 
while ( buf < endbuf ) { 
v = ( void* ) *buf; 
*buf = 0; 
buf++; 
typ = *buf; 
buf++; 
#line 502 "d:\Go1.1\src\pkg\runtime\malloc.goc"
p = ( uintptr ) v>>PageShift; 
if ( sizeof ( void* ) == 8 ) 
p -= ( uintptr ) runtime·mheap->arena_start >> PageShift; 
s = runtime·mheap->map[p]; 
#line 507 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( s->sizeclass == 0 ) { 
s->types.compression = MTypes_Single; 
s->types.data = typ; 
continue; 
} 
#line 513 "d:\Go1.1\src\pkg\runtime\malloc.goc"
size = s->elemsize; 
ofs = ( ( uintptr ) v - ( s->start<<PageShift ) ) / size; 
#line 516 "d:\Go1.1\src\pkg\runtime\malloc.goc"
switch ( s->types.compression ) { 
case MTypes_Empty: 
ntypes = ( s->npages << PageShift ) / size; 
nbytes3 = 8*sizeof ( uintptr ) + 1*ntypes; 
#line 521 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( !sysalloc ) { 
data3 = runtime·mallocgc ( nbytes3 , FlagNoProfiling|FlagNoPointers , 0 , 1 ) ; 
} else { 
data3 = runtime·SysAlloc ( nbytes3 ) ; 
if ( data3 == nil ) 
runtime·throw ( "runtime: cannot allocate memory" ) ; 
if ( 0 ) runtime·printf ( "settype(0->3): SysAlloc(%x) --> %p\n" , ( uint32 ) nbytes3 , data3 ) ; 
} 
#line 530 "d:\Go1.1\src\pkg\runtime\malloc.goc"
s->types.compression = MTypes_Bytes; 
s->types.sysalloc = sysalloc; 
s->types.data = ( uintptr ) data3; 
#line 534 "d:\Go1.1\src\pkg\runtime\malloc.goc"
( ( uintptr* ) data3 ) [1] = typ; 
data3[8*sizeof ( uintptr ) + ofs] = 1; 
break; 
#line 538 "d:\Go1.1\src\pkg\runtime\malloc.goc"
case MTypes_Words: 
( ( uintptr* ) s->types.data ) [ofs] = typ; 
break; 
#line 542 "d:\Go1.1\src\pkg\runtime\malloc.goc"
case MTypes_Bytes: 
data3 = ( byte* ) s->types.data; 
for ( j=1; j<8; j++ ) { 
if ( ( ( uintptr* ) data3 ) [j] == typ ) { 
break; 
} 
if ( ( ( uintptr* ) data3 ) [j] == 0 ) { 
( ( uintptr* ) data3 ) [j] = typ; 
break; 
} 
} 
if ( j < 8 ) { 
data3[8*sizeof ( uintptr ) + ofs] = j; 
} else { 
ntypes = ( s->npages << PageShift ) / size; 
nbytes2 = ntypes * sizeof ( uintptr ) ; 
#line 559 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( !sysalloc ) { 
data2 = runtime·mallocgc ( nbytes2 , FlagNoProfiling|FlagNoPointers , 0 , 1 ) ; 
} else { 
data2 = runtime·SysAlloc ( nbytes2 ) ; 
if ( data2 == nil ) 
runtime·throw ( "runtime: cannot allocate memory" ) ; 
if ( 0 ) runtime·printf ( "settype.(3->2): SysAlloc(%x) --> %p\n" , ( uint32 ) nbytes2 , data2 ) ; 
} 
#line 568 "d:\Go1.1\src\pkg\runtime\malloc.goc"
sysalloc3 = s->types.sysalloc; 
#line 570 "d:\Go1.1\src\pkg\runtime\malloc.goc"
s->types.compression = MTypes_Words; 
s->types.sysalloc = sysalloc; 
s->types.data = ( uintptr ) data2; 
#line 575 "d:\Go1.1\src\pkg\runtime\malloc.goc"
for ( j=0; j<ntypes; j++ ) { 
t = data3[8*sizeof ( uintptr ) + j]; 
t = ( ( uintptr* ) data3 ) [t]; 
data2[j] = t; 
} 
if ( sysalloc3 ) { 
nbytes3 = 8*sizeof ( uintptr ) + 1*ntypes; 
if ( 0 ) runtime·printf ( "settype.(3->2): SysFree(%p,%x)\n" , data3 , ( uint32 ) nbytes3 ) ; 
runtime·SysFree ( data3 , nbytes3 ) ; 
} 
#line 586 "d:\Go1.1\src\pkg\runtime\malloc.goc"
data2[ofs] = typ; 
} 
break; 
} 
} 
runtime·unlock ( &settype_lock ) ; 
#line 593 "d:\Go1.1\src\pkg\runtime\malloc.goc"
mp->settype_bufsize = 0; 
} 
#line 598 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void 
runtime·settype ( void *v , uintptr t ) 
{ 
M *mp; 
uintptr *buf; 
uintptr i; 
MSpan *s; 
#line 606 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( t == 0 ) 
runtime·throw ( "settype: zero type" ) ; 
#line 609 "d:\Go1.1\src\pkg\runtime\malloc.goc"
mp = m; 
buf = mp->settype_buf; 
i = mp->settype_bufsize; 
buf[i+0] = ( uintptr ) v; 
buf[i+1] = t; 
i += 2; 
mp->settype_bufsize = i; 
#line 617 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( i == nelem ( mp->settype_buf ) ) { 
runtime·settype_flush ( mp , false ) ; 
} 
#line 621 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( DebugTypeAtBlockEnd ) { 
s = runtime·MHeap_Lookup ( runtime·mheap , v ) ; 
* ( uintptr* ) ( ( uintptr ) v+s->elemsize-sizeof ( uintptr ) ) = t; 
} 
} 
#line 627 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void 
runtime·settype_sysfree ( MSpan *s ) 
{ 
uintptr ntypes , nbytes; 
#line 632 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( !s->types.sysalloc ) 
return; 
#line 635 "d:\Go1.1\src\pkg\runtime\malloc.goc"
nbytes = ( uintptr ) -1; 
#line 637 "d:\Go1.1\src\pkg\runtime\malloc.goc"
switch ( s->types.compression ) { 
case MTypes_Words: 
ntypes = ( s->npages << PageShift ) / s->elemsize; 
nbytes = ntypes * sizeof ( uintptr ) ; 
break; 
case MTypes_Bytes: 
ntypes = ( s->npages << PageShift ) / s->elemsize; 
nbytes = 8*sizeof ( uintptr ) + 1*ntypes; 
break; 
} 
#line 648 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( nbytes != ( uintptr ) -1 ) { 
if ( 0 ) runtime·printf ( "settype: SysFree(%p,%x)\n" , ( void* ) s->types.data , ( uint32 ) nbytes ) ; 
runtime·SysFree ( ( void* ) s->types.data , nbytes ) ; 
} 
} 
#line 654 "d:\Go1.1\src\pkg\runtime\malloc.goc"
uintptr 
runtime·gettype ( void *v ) 
{ 
MSpan *s; 
uintptr t , ofs; 
byte *data; 
#line 661 "d:\Go1.1\src\pkg\runtime\malloc.goc"
s = runtime·MHeap_LookupMaybe ( runtime·mheap , v ) ; 
if ( s != nil ) { 
t = 0; 
switch ( s->types.compression ) { 
case MTypes_Empty: 
break; 
case MTypes_Single: 
t = s->types.data; 
break; 
case MTypes_Words: 
ofs = ( uintptr ) v - ( s->start<<PageShift ) ; 
t = ( ( uintptr* ) s->types.data ) [ofs/s->elemsize]; 
break; 
case MTypes_Bytes: 
ofs = ( uintptr ) v - ( s->start<<PageShift ) ; 
data = ( byte* ) s->types.data; 
t = data[8*sizeof ( uintptr ) + ofs/s->elemsize]; 
t = ( ( uintptr* ) data ) [t]; 
break; 
default: 
runtime·throw ( "runtime·gettype: invalid compression kind" ) ; 
} 
if ( 0 ) { 
runtime·lock ( &settype_lock ) ; 
runtime·printf ( "%p -> %d,%X\n" , v , ( int32 ) s->types.compression , ( int64 ) t ) ; 
runtime·unlock ( &settype_lock ) ; 
} 
return t; 
} 
return 0; 
} 
#line 695 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void* 
runtime·mal ( uintptr n ) 
{ 
return runtime·mallocgc ( n , 0 , 1 , 1 ) ; 
} 
#line 701 "d:\Go1.1\src\pkg\runtime\malloc.goc"
#pragma textflag 7 
void 
runtime·new ( Type *typ , uint8 *ret ) 
{ 
uint32 flag; 
#line 707 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( raceenabled ) 
m->racepc = runtime·getcallerpc ( &typ ) ; 
#line 710 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( typ->size == 0 ) { 
#line 714 "d:\Go1.1\src\pkg\runtime\malloc.goc"
ret = ( uint8* ) &runtime·zerobase; 
} else { 
flag = typ->kind&KindNoPointers ? FlagNoPointers : 0; 
ret = runtime·mallocgc ( typ->size , flag , 1 , 1 ) ; 
#line 719 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( UseSpanType && !flag ) { 
if ( false ) { 
runtime·printf ( "new %S: %p\n" , *typ->string , ret ) ; 
} 
runtime·settype ( ret , ( uintptr ) typ | TypeInfo_SingleObject ) ; 
} 
} 
#line 727 "d:\Go1.1\src\pkg\runtime\malloc.goc"
FLUSH ( &ret ) ; 
} 
#line 731 "d:\Go1.1\src\pkg\runtime\malloc.goc"
void* 
runtime·cnew ( Type *typ ) 
{ 
uint32 flag; 
void *ret; 
#line 737 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( raceenabled ) 
m->racepc = runtime·getcallerpc ( &typ ) ; 
#line 740 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( typ->size == 0 ) { 
#line 744 "d:\Go1.1\src\pkg\runtime\malloc.goc"
ret = ( uint8* ) &runtime·zerobase; 
} else { 
flag = typ->kind&KindNoPointers ? FlagNoPointers : 0; 
ret = runtime·mallocgc ( typ->size , flag , 1 , 1 ) ; 
#line 749 "d:\Go1.1\src\pkg\runtime\malloc.goc"
if ( UseSpanType && !flag ) { 
if ( false ) { 
runtime·printf ( "new %S: %p\n" , *typ->string , ret ) ; 
} 
runtime·settype ( ret , ( uintptr ) typ | TypeInfo_SingleObject ) ; 
} 
} 
#line 757 "d:\Go1.1\src\pkg\runtime\malloc.goc"
return ret; 
} 
void
runtime·GC()
{
#line 760 "d:\Go1.1\src\pkg\runtime\malloc.goc"

	runtime·gc(1);
}
void
runtime·SetFinalizer(Eface obj, Eface finalizer)
{
#line 764 "d:\Go1.1\src\pkg\runtime\malloc.goc"

	byte *base;
	uintptr size;
	FuncType *ft;
	int32 i;
	uintptr nret;
	Type *t;

	if(obj.type == nil) {
		runtime·printf("runtime.SetFinalizer: first argument is nil interface\n");
		goto throw;
	}
	if(obj.type->kind != KindPtr) {
		runtime·printf("runtime.SetFinalizer: first argument is %S, not pointer\n", *obj.type->string);
		goto throw;
	}
	if(!runtime·mlookup(obj.data, &base, &size, nil) || obj.data != base) {
		runtime·printf("runtime.SetFinalizer: pointer not at beginning of allocated block\n");
		goto throw;
	}
	nret = 0;
	if(finalizer.type != nil) {
		if(finalizer.type->kind != KindFunc)
			goto badfunc;
		ft = (FuncType*)finalizer.type;
		if(ft->dotdotdot || ft->in.len != 1 || *(Type**)ft->in.array != obj.type)
			goto badfunc;

		// compute size needed for return parameters
		for(i=0; i<ft->out.len; i++) {
			t = ((Type**)ft->out.array)[i];
			nret = (nret + t->align - 1) & ~(t->align - 1);
			nret += t->size;
		}
		nret = (nret + sizeof(void*)-1) & ~(sizeof(void*)-1);
	}
	
	if(!runtime·addfinalizer(obj.data, finalizer.data, nret)) {
		runtime·printf("runtime.SetFinalizer: finalizer already set\n");
		goto throw;
	}
	return;

badfunc:
	runtime·printf("runtime.SetFinalizer: second argument is %S, not func(%S)\n", *finalizer.type->string, *obj.type->string);
throw:
	runtime·throw("runtime.SetFinalizer");
}
